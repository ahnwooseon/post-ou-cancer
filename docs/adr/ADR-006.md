# ADR-006: Blazor WASM and MudBlazor for the Public UI

## 1. Context

The project requires a modern, responsive, and performant front-end for the main user-facing application. Key requirements include the ability to create a rich, interactive single-page application (SPA), support for Progressive Web App (PWA) features for offline capabilities, and maintaining high developer velocity by leveraging the existing .NET ecosystem.

## 2. Decision

We will build the public web application using **Blazor WebAssembly (WASM)**. For the UI component library, we will use **MudBlazor**, which provides a comprehensive set of pre-built, Material Design-compliant components that accelerate development.

## 3. Status

Accepted.

## 4. Consequences

### Positive ✅

*   **Unified Language Stack (C#)**: Using Blazor allows for end-to-end development in C#, reducing the context-switching between a JavaScript front-end and a C# back-end. This enables code sharing for validation logic and data models, maximizing developer velocity for a solo developer.
*   **Rich Component Ecosystem**: MudBlazor is a mature and feature-rich component library that provides everything needed to build a complex application UI quickly, including data tables, dialogs, forms, and navigation elements.
*   **Performance and PWA**: Blazor WASM runs directly in the browser, enabling highly interactive, near-native user experiences. It has strong support for PWA features, which is critical for the "Local-First Storage" and offline capabilities outlined in the roadmap.
*   **Strong Tooling**: Development can be done entirely within Visual Studio or Rider, with excellent debugging support that allows stepping through both front-end and back-end C# code seamlessly.

### Negative ❌

*   **Initial Load Time**: Blazor WASM applications can have a larger initial download size compared to JavaScript frameworks because the .NET runtime is downloaded to the browser. **Mitigation**: This is addressed through .NET's built-in mechanisms for Intermediate Language (IL) trimming and Ahead-of-Time (AOT) compilation, which significantly reduce the payload size.
*   **WASM Browser Support**: While support is now ubiquitous in modern browsers, very old browsers may not be able to run the application. This is an acceptable trade-off for a new, forward-looking project.

## 5. Alternatives Considered

| Alternative                      | Rationale for Rejection                                                                                                                                                                                                                                                                                       |
| :------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Angular**                      | A powerful and robust framework (and chosen for the admin UI), but using it for the public UI would require maintaining two separate language stacks (TypeScript/C#) and eliminate the benefits of code sharing and unified tooling. The learning curve for its advanced concepts (RxJS, modules) is also steeper. |
| **React / Vue**                  | Both are excellent, popular JavaScript libraries with vast ecosystems. However, they would introduce the same dual-language challenge as Angular. Blazor provides a more integrated experience for a .NET-centric developer, which is the primary driver for this decision.                                           |
| **Blazor Server**                | Provides a similar component model but maintains a persistent SignalR connection to the server, which handles UI rendering. This model is not suitable for the project's goals of supporting offline PWA functionality and a "Local-First" architecture.                                                         |
