# ADR-004: Choosing PostgreSQL as the Primary Database

## 1. Context

The project requires a primary, relational database to serve as the authoritative source of truth for core business domains like Identity, Posts, Communities, and Governance. The chosen database must be reliable, performant, extensible, and well-supported within the .NET ecosystem. It also needs to handle structured relational data (users, posts) and semi-structured data (user settings, metadata) efficiently.

## 2. Decision

We will use **PostgreSQL** as the primary relational database for the application. It will be orchestrated via .NET Aspire in development and deployed as a high-availability cluster in production. All modules within the Modular Monolith will initially share this single database instance, but will use dedicated schemas (`posts`, `identity`, etc.) to enforce logical separation, as outlined in [ADR-002](./ADR-002.md).

## 3. Status

Accepted.

## 4. Consequences

### Positive ✅

*   **Rich Feature Set**: PostgreSQL's advanced features, particularly its mature JSONB support, are ideal for storing flexible metadata alongside structured relational data. Its built-in Full-Text Search provides a solid baseline search capability and a fallback option ([ADR-005](./ADR-005.md)).
*   **Reliability and Extensibility**: As a battle-tested, ACID-compliant RDBMS, it guarantees data integrity for critical operations. Its extension ecosystem (e.g., PostGIS) provides a clear path for adding advanced features in the future without changing the core database.
*   **Ecosystem and Tooling**: The Npgsql provider for Entity Framework Core is highly performant and well-maintained, ensuring seamless integration with our .NET stack. The broader ecosystem of tools for administration and monitoring is excellent.
*   **Cost-Effective**: Being a world-class open-source database, PostgreSQL has no licensing costs, which is a significant advantage for a new project.

### Negative ❌

*   **Operational Overhead**: Unlike a managed DBaaS, a self-hosted PostgreSQL cluster requires manual configuration for high availability, backups, and maintenance. **Mitigation**: The production plan (Milestone 15) explicitly includes setting up streaming replication and automated backups (e.g., using Patroni).
*   **Scaling Complexity**: Horizontal scaling for a relational database is inherently more complex than for many NoSQL alternatives. **Mitigation**: The application is designed to scale vertically for a significant time. The modular architecture allows for specific high-load data to be offloaded to specialized databases in the future if necessary.

## 5. Alternatives Considered

| Alternative           | Rationale for Rejection                                                                                                                                                                                                                         |
| :-------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **MySQL / MariaDB**   | A solid and popular open-source choice, but PostgreSQL's superior JSONB implementation and more powerful extensibility framework make it a better long-term fit for the project's goal of supporting a flexible, multi-universe architecture. |
| **Microsoft SQL Server** | Excellent performance and deep integration with the .NET ecosystem. However, its licensing costs for production can be substantial, and it offers less flexibility in a cross-platform, container-first deployment strategy compared to PostgreSQL. |
| **MongoDB (as primary)** | While excellent for unstructured data (and planned for secondary analytics), it lacks the ACID guarantees and strong consistency required for the core transactional logic of a social platform (e.g., ensuring a vote is counted exactly once). |
