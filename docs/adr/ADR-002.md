# ADR-002: Modular Monolith vs. Microservices Architecture

## 1. Context

The project requires strong architectural boundaries to handle diverse business domains (Posts, Communities, Governance, Identity) that underpin the **Multi-Universe Architecture**. However, the project is currently managed by a single developer, making **development velocity** and **low operational complexity** critical success factors.

The architecture must be manageable during the initial phases (PI-1 to PI-4) while providing a clear path for future scaling as the platform grows.

## 2. Decision

We choose the **Modular Monolith** architecture for the core application. The application will be structured into distinct, decoupled modules (e.g., `PostOuCancer.Posts`, `PostOuCancer.Governance`, `PostOuCancer.Identity`). These modules communicate primarily using in-process messaging (Mediator/Events) and share a single logical database (PostgreSQL).

We will use **FastEndpoints**, which builds upon the .NET Minimal API model, to define API endpoints within each module, ensuring a consistent and high-performance interface.

## 3. Status

Accepted.

## 4. Consequences

### Positive ✅

* **Maximum Developer Velocity**: A single codebase allows for rapid refactoring, simplified version control, and straightforward implementation of cross-cutting concerns (e.g., Authentication, Logging). This is the most significant advantage for a solo developer.
* **Simplified Deployment & Operations**: A single application artifact is built and deployed. This is dramatically easier to manage, monitor, and orchestrate with **.NET Aspire** ([ADR-003](ADR-003.md)) compared to a distributed system.
* **Effortless Debugging**: End-to-end debugging of complex business transactions is trivial, as it occurs within a single process. This avoids the immense overhead of distributed tracing and network-level diagnostics required by microservices.
* **Enforced Modularity**: Clear boundaries are enforced at compile time using .NET project references and public interfaces. This prevents architectural decay ("spaghetti code") and ensures modules remain decoupled and independently testable.
* **Painless Future Scalability**: The strict modular design provides a low-risk path to a microservices architecture. A specific, high-load module (e.g., the `Posts` module) can be "strangled" and extracted into a separate service later, if and when the need arises.
* **Guaranteed Transactional Integrity**: Business logic spanning multiple domains (e.g., creating a post and updating user karma) can be wrapped in a single, ACID-compliant database transaction, ensuring data consistency without the complexity of distributed transaction patterns like Sagas.

### Negative ❌

* **Database Contention at Scale**: Sharing a single database instance can become a performance bottleneck at extreme scale. **Mitigation**: Using separate database schemas per module from day one simplifies a future migration to separate physical databases.
* **Potential for Future Team Friction**: In a larger team (e.g., 10+ developers), a single codebase can lead to merge conflicts and longer build times. **Mitigation**: The strict modularity and clear ownership of modules are designed to minimize this risk.
* **Technology Stack Rigidity**: All modules are initially bound to the .NET/PostgreSQL stack. It is not possible to write one module in Go and another in C# without first extracting it into a full microservice. This is an acceptable trade-off for the initial velocity gains.

## 5. Alternatives Considered

| Alternative                                  | Rationale for Rejection                                                                                                                                                                                                                                       |
| :------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Full Microservices Architecture**          | Prohibitively complex for a solo developer. The upfront investment in distributed tracing, service discovery, API gateways, and distributed transaction patterns (Sagas) would cripple initial development velocity and provide no immediate business value. |
| **Simple Monolith (e.g., Layered)**          | Lacks the strict, enforceable boundaries required for long-term maintainability and future scaling. This approach would inevitably lead to tightly coupled "spaghetti code," making it impossible to evolve or scale individual features independently. |
| **Serverless (Functions-as-a-Service)**      | Introduces significant operational overhead for state management and can lead to vendor lock-in. While cost-effective for event-driven tasks, guaranteeing the consistent, low-latency performance (sub-150ms) required for the real-time "Stream" universe is challenging and complex. |
